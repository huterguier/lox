from functools import wraps
from typing import (
    Any,
    Callable,
    Hashable,
    Iterable,
    Sequence,
    overload,
    Literal,
    Optional,
)

import jax
import jax.core
import jax.extend
import jax.numpy as jnp
from jax import ShapeDtypeStruct
from jax._src import source_info_util
from jax.core import ShapedArray
from jax.extend.core import ClosedJaxpr, Jaxpr, JaxprEqn, Var

from lox.logdict import logdict
from lox.nolog import nolog_jaxpr
from lox.primitive import lox_p
from lox.util import flatten, is_hashable

AxisName = Hashable


def spool(
    fun: Callable,
    keep_logs=False,
    interval: Optional[int] = None,
    reduce: Optional[str] = None,
) -> Callable:
    """
    Spools a function to extract logs generated during its execution.
    Logs are generated by every call to ``lox.log`` within the function.
    Note that spooling also has to obey the underlying laws of JAX.
    Hence all shapes and lengths of the logs must be inferrable during compile time.
    As a direct consequence, loops with non-static lengths (e.g. while loops) are not supported.
    Another implication of this is that spooling an already jitted function that contains
    logging operations will trigger recompilation.

    Args:
        fun (Callable): The function to be spooled.
        keep_logs (bool): Whether to keep logs in the jaxpr.
        interval (Optional[int]): An optional interval to subsample the logs.
        reduce (Optional[int | str]): An optional reduction operation to apply to the logs.

    Returns:
        Callable: A wrapped function that returns the spooled jaxpr and logs.

    Example:
        Here is an example of how to use ``spool`` to extract logs from a function.

        >>> def f(x):
        >>>     lox.log({"x": x})
        >>>     return x + 1.0
        >>> spool(f)(1.0)
        (2.0, {'x': 1.0})

        Spooling works with arbitrarily nested functions and higher order primitives such as
        ``jax.lax.scan`` or ``jax.lax.cond``.
        The following example shows how to use spooling with a scan operation over the
        previously defined function ``f``.

        >>> def g(xs):
        >>>     carry, ys = jax.lax.scan(lambda c, x: (f(c), x), xs)
        >>>     lox.log({"carry": carry})
        >>> return ys
        >>> spool(g)(jnp.arange(3))
        (Array([2., 3., 4.]), {'carry': 3., 'x': Array([0., 1., 2.])})

        When logging inside of ``jax.lax.cond`` all branches must have the same log structure.
        In this case, both branches return a logdict containing only the key :string:`x`.

        >>> def h(x):
        >>>     return jax.lax.cond(x > 0, lambda x: f(x), lambda x: f(x + 1), x)
        >>> x = 3.0
        >>> spool(h)(x)
        (4.0, {'x': 3.0})

        The optional argument `keep_logs` can be set to `True` to keep the logs in the jaxpr.
        By default, spooling a function twice

        >>> def j(x):
        >>>     y, logs = spool(f)(x)
        >>>     return y
        >>> spool(j)(1.0)
        2.0

    """

    @wraps(fun)
    def wrapped(*args, **kwargs):
        args_flat, structure = jax.tree.flatten((args, kwargs))
        static_argnums = tuple(i for i, arg in enumerate(args_flat) if is_hashable(arg))
        closed_jaxpr, out_spooled_shape = make_spooled_jaxpr(
            flatten(fun, structure),
            static_argnums=static_argnums,
            return_shape=True,
            keep_logs=keep_logs,
        )(*args_flat)
        dynamic_args_flat = tuple(arg for arg in args_flat if not is_hashable(arg))
        out_spooled_structure = jax.tree.structure(out_spooled_shape)
        out_spooled_flat = jax.core.eval_jaxpr(
            closed_jaxpr.jaxpr, closed_jaxpr.literals, *dynamic_args_flat
        )
        out, logs = jax.tree_util.tree_unflatten(
            out_spooled_structure, out_spooled_flat
        )
        if interval is not None:
            logs = logs.slice[::interval]
        if reduce is not None:
            logs = logs.reduce(reduce)
        return out, logs

    return wrapped


@overload
def make_spooled_jaxpr(
    fun: Callable,
    static_argnums: int | Iterable[int] = (),
    axis_env: Sequence[tuple[AxisName, int]] | None = None,
    return_shape: Literal[False] = ...,
    abstracted_axes: Any | None = None,
    keep_logs: bool = False,
) -> Callable[..., ClosedJaxpr]: ...


@overload
def make_spooled_jaxpr(
    fun: Callable,
    static_argnums: int | Iterable[int] = (),
    axis_env: Sequence[tuple[AxisName, int]] | None = None,
    return_shape: Literal[True] = ...,
    abstracted_axes: Any | None = None,
    keep_logs: bool = False,
) -> Callable[..., tuple[ClosedJaxpr, Any]]: ...


def make_spooled_jaxpr(
    fun: Callable,
    static_argnums: int | Iterable[int] = (),
    axis_env: Sequence[tuple[AxisName, int]] | None = None,
    return_shape: bool = False,
    abstracted_axes: Any | None = None,
    keep_logs: bool = False,
) -> Callable[..., ClosedJaxpr] | Callable[..., tuple[ClosedJaxpr, Any]]:
    """
    Creates a spooled jaxpr for the given function, extracting logs and their shapes.

    Args:
        fun (Callable): The function to create a jaxpr for.
        static_argnums (int | Iterable[int]): The indices of static arguments.
        axis_env (Sequence[tuple[AxisName, int]] | None): The axis environment for the jaxpr.
        return_shape (bool): Whether to return the shape of the output.
        abstracted_axes (Any | None): Abstracted axes for the jaxpr.
        keep_logs (bool): Whether to keep logs in the jaxpr.
    Returns:
        Callable[..., ClosedJaxpr | tuple[ClosedJaxpr, Any]]: A wrapped function that returns the jaxpr and logs.
    """

    def make_jaxpr_f(*args, **kwargs):
        closed_jaxpr, out_shape = jax.make_jaxpr(
            fun,
            static_argnums=static_argnums,
            axis_env=axis_env,
            return_shape=True,
            abstracted_axes=abstracted_axes,
        )(*args, **kwargs)
        logs = spool_jaxpr(closed_jaxpr.jaxpr)
        logs_shape = jax.tree_util.tree_map(
            lambda v: ShapeDtypeStruct(v.aval.shape, v.aval.dtype), logs
        )
        if not keep_logs:
            nolog_jaxpr(closed_jaxpr.jaxpr)
        if return_shape:
            return closed_jaxpr, (out_shape, logs_shape)
        return closed_jaxpr

    make_jaxpr_f.__module__ = "jax"
    if hasattr(fun, "__qualname__"):
        make_jaxpr_f.__qualname__ = f"make_jaxpr({fun.__qualname__})"
    if hasattr(fun, "__name__"):
        make_jaxpr_f.__name__ = f"make_jaxpr({fun.__name__})"
    return make_jaxpr_f


def apply(f: Callable, jaxpr: Jaxpr, *invars: Any) -> Any:
    """
    Applies a function to the invars within the context of the jaxpr.

    Args:
        f (Callable): The function to apply.
        jaxpr (Jaxpr): The jaxpr context in which to apply the function.
        *invars: The input variables to the function.
    Returns:
        Any: The output variables after applying the function.
    """
    invars_avals = jax.tree.map(lambda invar: invar.aval, invars)
    closed_jaxpr_f, shape_f = jax.make_jaxpr(f, return_shape=True)(*invars_avals)
    structure_f = jax.tree.structure(shape_f)
    jaxpr_f = closed_jaxpr_f.jaxpr
    jaxpr.eqns.append(
        JaxprEqn(
            primitive=jax.extend.core.primitives.call_p,
            invars=jax.tree.leaves(invars),
            outvars=jaxpr_f.outvars,
            params={"call_jaxpr": jaxpr_f},
            source_info=source_info_util.current(),
            effects=(),
            ctx=jaxpr.eqns[0].ctx,
        )
    )
    outvars = jax.tree.unflatten(structure_f, jaxpr_f.outvars)
    return outvars


def spool_jaxpr(jaxpr: Jaxpr) -> logdict:
    """
    Spools the logs from a jaxpr, extracting logs and their shapes from each equation.
    Combines logs from nested equations in the order they will be executed.

    Args:
        jaxpr (Jaxpr): The jaxpr to spool.
    Returns:
        tuple[dict[str, Any], dict[str, Any]]: The logs and their shapes.
    """
    logs_eqns = []
    for i in range(len(jaxpr.eqns)):
        eqn = jaxpr.eqns[i]
        logs_eqn = None
        if eqn.primitive == lox_p:
            logs_eqn = spool_lox_p(jaxpr, eqn)
        elif eqn.primitive == jax.lax.scan_p:
            logs_eqn = spool_scan_p(jaxpr, eqn)
        elif eqn.primitive == jax.lax.cond_p:
            logs_eqn = spool_cond_p(jaxpr, eqn)
        elif eqn.primitive == jax.lax.while_p:
            logs_eqn = spool_while_p(jaxpr, eqn)
        elif eqn.primitive.name == "pjit":
            logs_eqn = spool_pjit_p(jaxpr, eqn)
        elif eqn.primitive == jax.extend.core.primitives.call_p:
            logs_eqn = spool_call_p(jaxpr, eqn)

        if logs_eqn:
            logs_eqns.append(logs_eqn)

    if logs_eqns:

        def combine(logs_eqns):
            """Combines the logs from multiple equations into a single logdict."""
            logs_jaxpr = logs_eqns[0]
            for logs_eqn in logs_eqns[1:]:
                logs_jaxpr += logs_eqn
            return logs_jaxpr

        logs_jaxpr = apply(combine, jaxpr, logs_eqns)
        jaxpr.outvars.extend(jax.tree_util.tree_leaves(logs_jaxpr))
    else:
        logs_jaxpr = logdict({})

    return logs_jaxpr


def spool_lox_p(jaxpr: Jaxpr, eqn: JaxprEqn) -> logdict:
    """
    Spools the logs from a lox_p primitive. The logs are extracted from the equation's parameters.

    Args:
        eqn (JaxprEqn): The equation representing the lox_p operation.
    Returns:
        tuple[dict[str, Any], dict[str, Any]]: The logs and their shapes.
    """
    del jaxpr
    logs_eqn = jax.tree.unflatten(eqn.params["structure"], eqn.invars)
    return logs_eqn


def spool_scan_p(jaxpr: Jaxpr, eqn: JaxprEqn) -> logdict:
    """
    Spools the logs from a scan_p primitive. The logs of the jaxpr are reshaped to have a static length,
    which is the length of the scan.
    """
    logs_jaxpr = spool_jaxpr(eqn.params["jaxpr"].jaxpr)
    logs_jaxpr_avals = jax.tree_util.tree_map(lambda l: l.aval, logs_jaxpr)

    logs_scan_avals = jax.tree_util.tree_map(
        lambda aval: ShapedArray((eqn.params["length"],) + aval.shape, aval.dtype),
        logs_jaxpr_avals,
    )
    logs_scan = jax.tree.map(lambda aval: Var(aval=aval), logs_scan_avals)
    eqn.outvars.extend(jax.tree.leaves(logs_scan))

    def unstack(logs_scan):
        """Unstacks the logs from the scan, to have a single leading dimension."""
        return jax.tree.map(
            lambda l: l.reshape((-1,) + l.shape[2:]),
            logs_scan,
        )

    logs_eqn = apply(unstack, jaxpr, logs_scan)

    return logs_eqn


def spool_cond_p(jaxpr: Jaxpr, eqn: JaxprEqn) -> logdict:
    """
    Spools the branches of a cond_p primitive. All branches must have the same log structure and shapes.

    Args:
        eqn (JaxprEqn): The equation representing the switch operation.
    Returns:
        logdict: The logs and their shapes for the branches.
    Raises:
        ValueError: If the branches do not have the same log structure or shapes.
    """
    del jaxpr
    branches = eqn.params["branches"]
    logs_branches = []

    for branch in branches:
        logs_branch = spool_jaxpr(branch.jaxpr)
        logs_branches.append(logs_branch)

    logs_eqn = jax.tree.map(
        lambda l: Var(aval=ShapedArray(l.aval.shape, l.aval.dtype)), logs_branches[0]
    )
    eqn.outvars.extend(jax.tree.leaves(logs_eqn))

    return logs_eqn


def spool_while_p(jaxpr: Jaxpr, eqn: JaxprEqn) -> logdict:
    """
    Spools the inner jaxpr of a while_p primitive. If the jaxpr contains any logging operations,
        it raises an error since while loops have non-static lengths.

    Args:
        eqn (JaxprEqn): The equation representing the while loop.
    Returns:
        logdict: An empty logdict, as spooling is not supported for while loops.
    Raises:
        ValueError: If the jaxpr contains any logging operations, since while loops have non-static lengths.
    """
    del jaxpr
    logs_cond = spool_jaxpr(eqn.params["cond_jaxpr"].jaxpr)
    logs_body = spool_jaxpr(eqn.params["body_jaxpr"].jaxpr)
    if logs_cond or logs_body:
        raise ValueError(
            "Spooling for while loops is not supported due to non-static length."
        )
    return logdict({})


def spool_pjit_p(jaxpr: Jaxpr, eqn: JaxprEqn) -> logdict:
    """
    Spools the jaxpr of a pjit primitive. As spooling the function would trigger recompilation,
    the wrapping pjit is removed if the jaxpr contains any lox_p primitives.

    Args:
        eqn (JaxprEqn): The equation representing the pjit operation.
    Returns:
        tuple[dict[str, Any], dict[str, Any]]: The logs and their shapes.
    """
    del jaxpr
    logs_jaxpr = spool_jaxpr(eqn.params["jaxpr"].jaxpr)
    if logs_jaxpr:
        logs_eqn = jax.tree.map(
            lambda l: Var(aval=ShapedArray(l.aval.shape, l.aval.dtype)), logs_jaxpr
        )
        eqn.outvars.extend(jax.tree.leaves(logs_eqn))
        eqn.primitive = jax.extend.core.primitives.call_p
        eqn.params = {"call_jaxpr": eqn.params["jaxpr"].jaxpr}
        return logs_eqn
    else:
        return logdict({})


def spool_call_p(jaxpr: Jaxpr, eqn: JaxprEqn) -> logdict:
    """
    Spools the jaxpr of a call_p primitive. This is used to handle the case where a function is called
    within a jaxpr, allowing us to track logs from the called function.

    Args:
        eqn (JaxprEqn): The equation representing the call operation.
    Returns:
        tuple[dict[str, Any], dict[str, Any]]: The logs and their shapes.
    """
    del jaxpr
    logs_call_jaxpr = spool_jaxpr(eqn.params["call_jaxpr"])
    logs_eqn = jax.tree.map(
        lambda l: Var(aval=ShapedArray(l.aval.shape, l.aval.dtype)), logs_call_jaxpr
    )
    eqn.outvars.extend(jax.tree_util.tree_leaves(logs_eqn))
    return logs_eqn
